CLIBRARIES = -lftdi1

ifeq ($(OS), Windows_NT)
	CC = x86_64-w64-mingw32-gcc
	CLIBRARIES += -lusb-1.0

	COMMAND_LINE_EXECUTABLE_PREFIX=windows_x86_64_
	COMMAND_LINE_EXECUTABLE_SUFFIX=.exe
else
	CC = clang
	UNAME_S := $(shell uname -s)
	UNAME_P := $(shell uname -p)

	ifeq ($(UNAME_S), Linux)
		ifeq ($(UNAME_P), x86_64)
			COMMAND_LINE_EXECUTABLE_PREFIX=linux_x86_64_
			COMMAND_LINE_EXECUTABLE_SUFFIX=
		else ifeq ($(UNAME_P), aarch64)
			COMMAND_LINE_EXECUTABLE_PREFIX=linux_aarch64_
			COMMAND_LINE_EXECUTABLE_SUFFIX=
		else
$(error Unknown architecture $(UNAME_P).)
		endif
	else ifeq ($(UNAME_S), Darwin)
		ifeq ($(UNAME_P), x86_64)
			COMMAND_LINE_EXECUTABLE_PREFIX=macos_x86_64_
			COMMAND_LINE_EXECUTABLE_SUFFIX=
		else ifeq ($(UNAME_P), arm)
			COMMAND_LINE_EXECUTABLE_PREFIX=macos_arm_
			COMMAND_LINE_EXECUTABLE_SUFFIX=
		else
$(error Unknown architecture $(UNAME_P).)
		endif
	else
$(error Unknown OS $(UNAME_S).)
	endif
endif

CFLAGS = -Wall -Wextra -Werror -std=c89 -O3 -pedantic

SOURCE = source
SOURCE_CASINGS = $(SOURCE)/casings
SOURCE_CASINGS_COMMON_SCAD = $(SOURCE_CASINGS)/common.scad
SOURCE_COMMAND_LINE_EXECUTABLES = $(SOURCE)/command_line_executables
SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES = $(SOURCE_COMMAND_LINE_EXECUTABLES)/libraries
SOURCE_COMMAND_LINE_EXECUTABLES_APPLICATIONS = $(SOURCE_COMMAND_LINE_EXECUTABLES)/applications

EPHEMERAL = ephemeral
EPHEMERAL_CASINGS = $(EPHEMERAL)/casings
EPHEMERAL_COMMAND_LINE_EXECUTABLES = $(EPHEMERAL)/command_line_executables
EPHEMERAL_COMMAND_LINE_EXECUTABLES_OBJECTS = $(EPHEMERAL_COMMAND_LINE_EXECUTABLES)/objects
EPHEMERAL_COMMAND_LINE_EXECUTABLES_EXECUTABLES = $(EPHEMERAL_COMMAND_LINE_EXECUTABLES)/executables

# Unfortunately, I have found that make quite often selects the wrong shell
# (e.g. PowerShell), so commands like "find" won't work unless we explicitly
# specify bash.  You also can't use a variable for this (e.g. $(SHELL)) as make
# inexplicably tries to read something from the PATH and fails.  So hardcoding a
# reference to bash seems to be the only way to get a working build.
SOURCE_CASINGS_SCAD = $(filter-out $(SOURCE_CASINGS_COMMON_SCAD), $(shell bash -c "find $(SOURCE_CASINGS) -type f -iname \"*.scad\""))
EPHEMERAL_CASINGS_STL = $(patsubst $(SOURCE_CASINGS)/%.scad, $(EPHEMERAL_CASINGS)/%.stl, $(SOURCE_CASINGS_SCAD))

SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES_H = $(shell bash -c "find $(SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES) -type f -iname \"*.h\"")

SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES_C = $(shell bash -c "find $(SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES) -type f -iname \"*.c\"")
EPHEMERAL_COMMAND_LINE_EXECUTABLES_LIBRARIES_O = $(patsubst $(SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES)/%.c, $(EPHEMERAL_COMMAND_LINE_EXECUTABLES_OBJECTS)/%.o, $(SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES_C))

SOURCE_COMMAND_LINE_EXECUTABLES_APPLICATIONS_C = $(shell bash -c "find $(SOURCE_COMMAND_LINE_EXECUTABLES_APPLICATIONS) -type f -iname \"*.c\"")
EPHEMERAL_COMMAND_LINE_EXECUTABLES_EXECUTABLES_APPLICATIONS = $(patsubst $(SOURCE_COMMAND_LINE_EXECUTABLES_APPLICATIONS)/%.c, $(EPHEMERAL_COMMAND_LINE_EXECUTABLES_EXECUTABLES)/$(COMMAND_LINE_EXECUTABLE_PREFIX)%$(COMMAND_LINE_EXECUTABLE_SUFFIX), $(SOURCE_COMMAND_LINE_EXECUTABLES_APPLICATIONS_C))

build: $(EPHEMERAL_CASINGS_STL) $(EPHEMERAL_COMMAND_LINE_EXECUTABLES_EXECUTABLES_APPLICATIONS)

$(EPHEMERAL_CASINGS)/%.stl: $(SOURCE_CASINGS)/%.scad $(SOURCE_CASINGS_COMMON_SCAD) makefile
	mkdir -p $(dir $@)
	openscad --hardwarnings --render --o $@ $<

$(EPHEMERAL_COMMAND_LINE_EXECUTABLES_EXECUTABLES)/$(COMMAND_LINE_EXECUTABLE_PREFIX)%$(COMMAND_LINE_EXECUTABLE_SUFFIX): $(SOURCE_COMMAND_LINE_EXECUTABLES_APPLICATIONS)/%.c $(EPHEMERAL_COMMAND_LINE_EXECUTABLES_LIBRARIES_O)
	mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -flto $< $(EPHEMERAL_COMMAND_LINE_EXECUTABLES_LIBRARIES_O) $(CLIBRARIES) -o $@

$(EPHEMERAL_COMMAND_LINE_EXECUTABLES_OBJECTS)/%.o: $(SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES)/%.c makefile $(SOURCE_COMMAND_LINE_EXECUTABLES_LIBRARIES_H)
	mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -rf $(EPHEMERAL)
